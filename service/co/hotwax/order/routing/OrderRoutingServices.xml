<?xml version="1.0" encoding="UTF-8"?>
<!--
    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.
-->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://moqui.org/xsd/service-definition-3.xsd">

    <service verb="clean" noun="OrderRoutingRun" authenticate="false" transaction-timeout="600">
        <description>Deletes OrderRoutingRun records older than a specified number of days.</description>
        <in-parameters><parameter name="daysToKeep" type="Integer" default="60"/></in-parameters>
        <out-parameters><parameter name="recordsRemoved" type="Long"/></out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.entity.EntityCondition
                Calendar basisCal = ec.user.getCalendarSafe()
                basisCal.add(Calendar.DAY_OF_YEAR, (int) - daysToKeep)
                basisTimestamp = new Timestamp(basisCal.getTimeInMillis())
            ]]></script>

            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingBatch" list="routingBatches">
                <econdition field-name="startDate" operator="less-equals" from="basisTimestamp"/>
                <use-iterator/>
            </entity-find>
            <set field="recordsRemoved" value="0" type="Long"/>
            <iterate list="routingBatches" entry="routingBatch">
                <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRun" list="routingRuns">
                    <econdition field-name="routingBatchId" from="routingBatch.routingBatchId"/>
                    <use-iterator/>
                </entity-find>
            <iterate list="routingRuns" entry="routingRun">
                <service-call name="delete#co.hotwax.order.routing.OrderRoutingRun" in-map="[routingRunId:routingRun.routingRunId]" transaction="force-new" ignore-error="true"/>
                <script>recordsRemoved++</script>
            </iterate>
                <service-call name="delete#co.hotwax.order.routing.OrderRoutingBatch" in-map="[routingBatchId:routingBatch.routingBatchId]" transaction="force-new" ignore-error="true"/>
            </iterate>
            <log message="Removed ${recordsRemoved} OrderRoutingRun records."/>
        </actions>
    </service>
    <service verb="scheduleNow" noun="OrderRoutingGroup">
        <description>
            This service schedules the routing process for an Order Routing Group.
            If the routing group schedule is not configured, the service will first create a schedule with a "pause" status (i.e., pause = "Y"),
            then service will trigger the framework to schedule the order routing group for immediate processing.
            The service utilizes the ScheduleJob functionality to initiate the process.
            Parameters for this execution are retrieved from the ServiceJobParameter.
            It's important to note that this service is designed to handle Order Routing Groups and not intended for scheduling individual orders.
        </description>
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="jobRunId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="Order routing group not found for routingGroupId [${routingGroupId}]."/>
            </if>
            <!-- If the OrderRoutingGroup is not scheduled, schedule it first before running the routing process -->
            <if condition="!orderRoutingGroup.jobName">
                <service-call name="co.hotwax.order.routing.OrderRoutingServices.store#OrderRoutingGroupSchedule" in-map="[routingGroupId: routingGroupId]" transaction="force-new"/>
                <script>orderRoutingGroup.refresh()</script>
            </if>
            <script>
                jobRunId = ec.service.job(orderRoutingGroup.jobName).run()
            </script>
            <return message="Scheduled job run ${jobRunId} for order routing group ${orderRoutingGroup.groupName} [${routingGroupId}]."/>
        </actions>

    </service>

    <service verb="run" noun="OrderRoutingGroup" transaction-timeout="36000" authenticate="anonymous-all"
             semaphore="wait" semaphore-parameter="productStoreId" semaphore-timeout="3600" semaphore-sleep="60"
             semaphore-ignore="7200" semaphore-name="OrderRoutingGroup">
        <description>
            The action initiates the processing or execution sequence for an Order Routing within the system.
            This procedure is crucial for managing and directing orders through the appropriate fulfillment pathways based on predefined criteria and rules set within the Order Routing Group.
            This service is designed to retrieve active order routings for a specified OrderRoutingGroup based on their sequence number.
            It aims to prioritize and organize order processing efficiently, ensuring that orders are routed and fulfilled according to pre-established sequences that optimize logistics, delivery times, and resource allocation.
        </description>
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
            <parameter name="orderRoutingId"/>
            <parameter name="routingRuleId"/>
            <parameter name="productStoreId" required="true"/>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
            <parameter name="changeReasonEnumId"/>
            <parameter name="testDriveSessionId">
                <description>
                    For test drive mode, if the productStore has brokering disabled (enableBrokering is set to "N") and a valid testDriveSessionId is provided, the brokering group will be executed.
                </description>
            </parameter>
            <!--
            In order to leverage the Service semaphore capabilities provided by the framework, we have chosen to include productStoreId as an input parameter.
            While productStoreId already exists in the OrderRoutingGroup entity,
            opting to use it as an input parameter allows us to seamlessly utilize the framework's existing functionality.

            By incorporating productStoreId as an input parameter,
            we can take advantage of the framework's built-in features without the need for additional custom handling.
            This approach aligns with the established design principles within the framework and ensures a more streamlined and maintainable solution.
            -->
        </in-parameters>
        <out-parameters>
            <parameter name="attemptedItemCount" type="Long"/>
            <parameter name="brokeredItemCount" type="Long"/>
        </out-parameters>
        <actions>
            <!-- validate the routing group and productStore association -->
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>

            <if condition="!orderRoutingGroup">
                <return error="true" message="Order routing not found for ${routingGroupId}"/>
            </if>
            <if condition="!orderRoutingGroup.productStoreId">
                <return error="true" message="No productStore associated with routing group ${orderRoutingGroup.groupName} [${routingGroupId}]"/>
            </if>
            <if condition="orderRoutingGroup.productStoreId != productStoreId">
                <return error="true" message="Order routing group ${orderRoutingGroup.groupName} [${routingGroupId}] is not associated with productStoreId [${productStoreId}]."/>
            </if>
            <entity-find-one entity-name="org.apache.ofbiz.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId" from="orderRoutingGroup.productStoreId"/>
            </entity-find-one>
            <if condition="!productStore">
                <return error="true" message="ProductStore ${orderRoutingGroup.productStoreId} not found."/>
            </if>
            <if condition="productStore.enableBrokering == 'N'">
                <!--
                    Allow routing in test drive mode even if brokering is disabled for the productStore.
                    This is permitted only if a valid testDriveSessionId is provided and the session is
                    associated with the same productStore. Otherwise, routing is blocked as expected.
                -->

                <if condition="testDriveSessionId">
                    <entity-find-one entity-name="co.hotwax.user.UserSession" value-field="userSession">
                        <field-map field-name="userSessionId" from="testDriveSessionId"/>
                    </entity-find-one>
                    <if condition="userSession &amp;&amp; userSession.productStoreId == productStore.productStoreId">
                        <log level="warn" message="Running routing group ${orderRoutingGroup.groupName} [${routingGroupId}] for test drive session ${testDriveSessionId}${orderId ? ' for order id ' + orderId : ''} "/>
                        <else>
                            <return error="true" message="Test derive ${testDriveSessionId} is not associated with productStore ${productStore.storeName} [${productStore.productStoreId}]."/>
                        </else>
                    </if>
                    <else>
                        <return message="Routing is disabled for ProductStore ${productStore.storeName} [${orderRoutingGroup.productStoreId}]. "/>
                    </else>
                </if>
            </if>

            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRun" list="routingRuns">
                <econditions>
                    <econdition field-name="routingGroupId" from="routingGroupId"/>
                    <econdition field-name="productStoreId" from="orderRoutingGroup.productStoreId"/>
                    <econdition field-name="endDate" from="null"/>
                </econditions>
                <order-by field-name="-startDate"/>
            </entity-find>
            <set field="routingRun" from="routingRuns?routingRuns[0]: null"/>
            <!-- If an routing run is in execution, Expire the current run -->
            <if condition="routingRun">
                    <service-call name="update#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                            in-map="[routingRunId:routingRun.routingRunId,hasError:'Y',
                                    routingResult:'Start a new force order routing run, bringing the current routing run to an end',
                                    endDate:ec.user.nowTimestamp]" out-map="routingRunResult"/>
            </if>
            <if condition="orderRoutingId">
                <log level="warn" message="Order routing group ${orderRoutingGroup.groupName} [${routingGroupId}] for order routing id ${orderRoutingId} and routing rule ${routingRuleId}"/>
            </if>
            <!-- Get the all active routing for order routing group -->
            <entity-find entity-name="co.hotwax.order.routing.OrderRouting" list="orderRoutings">
                <econditions>
                    <econdition field-name="orderRoutingId" from="orderRoutingId" ignore-if-empty="true"/>
                    <econdition field-name="routingGroupId" from="routingGroupId"/>
                    <econdition field-name="statusId" value="ROUTING_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <if condition="!orderRoutings">
                <return type="warning" message="No order routing configuration found for the specified routing group ${orderRoutingGroup.groupName?:''} [${routingGroupId}]."/>
            </if>
            <set field="groupItemCount" value="0" type="Long"/>
            <set field="groupBrokeredItemCount"  value="0" type="Long"/>
            <log message="Started order routing for ${orderRoutingGroup.groupName} [${routingGroupId}] routing group."/>
            <service-call name="create#co.hotwax.order.routing.OrderRoutingBatch" transaction="force-new" ignore-error="true"
                          in-map="[routingGroupId:routingGroupId, startDate:ec.user.nowTimestamp, createdByUserId:ec.user.userId]"
                          out-map="routingBatchResult"/>
            <set field="routingBatchId" from="routingBatchResult.routingBatchId"/>
            <iterate list="orderRoutings" entry="orderRouting">
                <service-call name="create#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingGroupId:routingGroupId, orderRoutingId: orderRouting.orderRoutingId,
                                productStoreId: productStoreId, startDate:ec.user.nowTimestamp, routingBatchId: routingBatchId]"
                        out-map="routingRunResult"/>
                <set field="attemptedItemCount" value="0" type="Long"/>
                <set field="brokeredItemCount" value="0" type="Long"/>
                <script><![CDATA[
                   /*
                        Calling a service in a script with ignore-error="true".
                        In this scenario, there is no direct way to identify if the service returned an error.
                        As we want to log the hasError status at the OrderRoutingRun level, to address this we are calling service in script tag
                    */

                    try {
                        def orderRoutingResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.run#OrderRouting")
                                .requireNewTransaction(true)
                                .parameters([orderRoutingId: orderRouting.orderRoutingId, orderId: orderId, shipGroupSeqId: shipGroupSeqId,
                                        routingRunId: routingRunResult.routingRunId, routingRuleId: routingRuleId])
                                .call()
                        attemptedItemCount = orderRoutingResult.attemptedItemCount?:0
                        brokeredItemCount = orderRoutingResult.brokeredItemCount?:0
                        groupItemCount += attemptedItemCount
                        groupBrokeredItemCount +=brokeredItemCount
                    } catch (Throwable e) {
                        ec.logger.error("There is an issue with run#OrderRouting", e)
                    }
                    def routingResult = null
                    def hasError = "N"
                    if (ec.message.hasError()) {
                        hasError = "Y"
                        routingResult = ec.message.getErrorsString()
                    } else {
                        routingResult = ec.message.getMessagesString()
                    }
                    if (routingResult && routingResult.length() > 255) {
                        routingResult = routingResult.substring(0, 255)
                    }
                    ec.message.clearAll();
                ]]></script>

                <service-call name="update#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingRunId:routingRunResult.routingRunId,hasError:hasError, routingResult:routingResult,
                                endDate:ec.user.nowTimestamp, orderItemCount: attemptedItemCount, brokeredItemCount: brokeredItemCount]"
                        out-map="routingRunResult"/>
            </iterate>

            <service-call name="update#co.hotwax.order.routing.OrderRoutingBatch" transaction="force-new" ignore-error="true"
                          in-map="[routingBatchId:routingBatchId, endDate:ec.user.nowTimestamp, orderItemCount: groupItemCount, brokeredItemCount: groupBrokeredItemCount]"/>
            <set field="attemptedItemCount" from="groupItemCount"/>
            <set field="brokeredItemCount" from="groupBrokeredItemCount"/>
            <message type="success">Finished order routing for the ${orderRoutingGroup.groupName} routing group with an attempted order item count of ${groupItemCount} and a brokered item count of ${groupBrokeredItemCount}</message>
        </actions>
    </service>

    <service verb="run" noun="OrderRouting" transaction-timeout="36000">
        <description>
            The service is to streamline the fulfillment process by intelligently routing orders through the system based on predefined conditions and rules.
            This service aims to optimize inventory distribution and order fulfillment efficiency by dynamically applying routing rules to each order's ship group,
            ensuring that inventory allocation and subsequent actions are aligned with business logistics and inventory management strategies.
        </description>
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
            <parameter name="routingRuleId">
                <description>Optional parameters, used when the user wants to run order routing with a specific order routing rule.</description>
            </parameter>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
            <parameter name="changeReasonEnumId"/>
            <parameter name="routingRunId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="attemptedItemCount" type="Long"/>
            <parameter name="brokeredItemCount" type="Long"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="true"/>
            <if condition="!orderRouting">
                <return error="true" message="No order routing found for id ${orderRoutingId}"/>
            </if>
            <if condition="!'ROUTING_ACTIVE'.equals(orderRouting.statusId)">
                <return error="true" message="Order routing ${orderRouting.routingName} [${orderRoutingId}] is not active"/>
            </if>
            <entity-find-related-one value-field="orderRouting" relationship-name="co.hotwax.order.routing.OrderRoutingGroup" to-value-field="orderRoutingGroup" cache="true"/>
            <log message="Started order routing ${orderRouting.routingName} [${orderRoutingId}]"/>

            <entity-find entity-name="co.hotwax.order.routing.OrderFilterCondition" list="orderFilterConditions">
                <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                <order-by field-name="sequenceNum"/>
                <order-by field-name="createdDate DESC"/>
            </entity-find>
            <!-- Prepare the filter conditions for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <!-- Prepare the order by for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <set field="orderSortByList" from="sortFields != null ? sortFields.fieldName:[]" type="List"/>
            <if condition="routingRuleId">
                <log level="warn" message="Running order routing ${orderRouting.routingName} [${orderRoutingId}] for specific rule ${routingRuleId}"/>
            </if>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRule" list="orderRoutingRules">
                <econditions>
                    <econdition field-name="routingRuleId" from="routingRuleId" ignore-if-empty="true"/>
                    <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                    <econdition field-name="statusId" value="RULE_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <if condition="!orderRoutingRules">
                <return error="true" message="No active routing rule found for order routing '${orderRouting.routingName}' [${orderRoutingId}]."/>
            </if>

            <set field="orderTypeId" value="SALES_ORDER"/>
            <set field="productStoreId" from="orderRoutingGroup.productStoreId"/>
            <set field="itemStatusId" value="ITEM_APPROVED"/>
            <set field="orderStatusId" value="ORDER_APPROVED"/>
            <set field="facilityParentTypeId" value="VIRTUAL_FACILITY"/>
            <set field="selectOrderItemSeqId" value="false" type="Boolean"/>
            <set field="orderFilterConditions" from="[]"/>
            <set field="attemptedCount" value="0" type="Integer"/>
            <iterate list="filterConditions" entry="filterCondition">
                <if condition='"promiseDaysCutoff".equals(filterCondition.fieldName)'>
                    <if condition="filterCondition.fieldValue">
                        <!--
                        When promiseDaysCutoff is configured, it acts as a constraint that prioritizes order items to be processed and allocated in a way that meets the delivery promise timeframe.
                        The brokering process is executed at the individual order item level rather than at a more aggregated shipGroup level.
                        -->
                        <set field="selectOrderItemSeqId" value="true" type="Boolean"/>
                        <script>
                            promisedDatetime = java.time.ZonedDateTime.now().plusDays(filterCondition.fieldValue as Long)
                                    .with(java.time.LocalTime.MAX).format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"))
                        </script>
                        <set field="orderFilterConditions" from="orderFilterConditions + [fieldName: 'promisedDatetime', operator: filterCondition.operator, fieldValue: promisedDatetime]"/>
                    </if>
                <else-if condition='"originFacilityGroupId".equals(filterCondition.fieldName)'>
                    <set field="facilityGroupCondition" from="filterCondition"/>
                </else-if>
                <else-if condition='"productCategoryId".equals(filterCondition.fieldName)'>
                    <set field="productCategoryCondition" from="filterCondition"/>
                </else-if>
                <else>
                    <set field="orderFilterConditions" from="orderFilterConditions + filterCondition"/>
                </else>
                </if>
            </iterate>
            <set field="queryCount" value="true" type="Boolean"/>
            <set field="templateLoc" value="component://order-routing/sql/EligibleOrdersQuery.sql.ftl"/>
            <set field="productStore" from="ec.entity.getEntityDefinition('org.apache.ofbiz.product.store.ProductStore')"/>
            <set field="attemptedItemCount" value="0" type="Long"/>
            <set field="brokeredItemCount" value="0" type="Long"/>
            <log message="Fetching order with condition ${orderFilterConditions} for routing ${orderRouting.routingName} [${orderRoutingId}]"/>
            <script><![CDATA[
                Writer countWriter = new StringWriter()
                ec.resourceFacade.template(templateLoc, countWriter)
                //ec.logger.info("Eligible orders count sql: ${countWriter}")
                ec.getEntity().getConnection(productStore.getEntityGroupName()).withCloseable ({ java.sql.Connection con ->
                    con.createStatement().withCloseable({ statement ->
                        statement.executeQuery(countWriter.toString()).withCloseable({resultSet ->
                            if (resultSet.next()) { attemptedItemCount = resultSet.getLong(1) }
                        })
                    })
                })
                Writer writer = new StringWriter()
                //queryCount field used in template, if it set true template return count only
                queryCount = false;
                ec.resourceFacade.template(templateLoc, writer)
                //ec.logger.info("Eligible orders sql: ${writer}")
                /** Note:
                        We can use statement.executeQuery as well.
                        However, using `requireNewTransaction` causes issues with `ResultSet` objects.
                        When `requireNewTransaction` is used, the `ResultSet` gets closed prematurely.
                 */
                def fieldList =['orderId', 'shipGroupSeqId'];
                if (selectOrderItemSeqId) {
                    fieldList.add('orderItemSeqId')
                }
                /*  The ec.entityFacade.sqlFind method is used to execute custom SQL queries,
                    but it requires that an entity exists in the system so that field mappings can be retrieved.
                    We are utilizing the framework's capabilities to obtain an iterator over the list of entities
                    that match the SQL query generated from a template.

                    Since we are only retrieving a limited set of fields related to OrderItem in the result set,
                    it is necessary to define an entity in the system that corresponds to these fields.
                    This entity allows us to map the results from the SQL query to the corresponding fields in the system.
                */

                try (eli = ec.entityFacade.sqlFind(writer.toString(), null, "co.hotwax.order.OrderItemsQueue", fieldList)) {
                    EntityValue nextValue
                    while ((nextValue = (EntityValue) eli.next()) != null) {
                        attemptedCount++;
                        def orderItemSeqId = null;
                        if (selectOrderItemSeqId) {
                          orderItemSeqId = nextValue.orderItemSeqId
                        }
                        ruleIterator = orderRoutingRules.iterator()
                        while (ruleIterator.hasNext()) {
                            def routingRule = ruleIterator.next()
                            ruleResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.run#OrderRoutingRule")
                                    .parameters([routingRuleId: routingRule.routingRuleId,
                                            orderId: nextValue.orderId, shipGroupSeqId: nextValue.shipGroupSeqId, orderItemSeqId: orderItemSeqId])
                                    .requireNewTransaction(true)
                                    .call()

                            if (!ec.message.hasError()) {
                                actionResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.eval#OrderRoutingActions")
                                        .parameters([orderId: nextValue.orderId, shipGroupSeqId: nextValue.shipGroupSeqId,orderItemSeqId: orderItemSeqId, changeReasonEnumId: changeReasonEnumId,
                                                routingRuleId: routingRule.routingRuleId, suggestedFulfillmentLocations: ruleResult.suggestedFulfillmentLocations, routingRunId: routingRunId])
                                        .requireNewTransaction(true)
                                        .call()
                                if (ec.message.hasError()) {
                                    ec.logger.warn("Ignoring order routing actions errors for ${routingRule.ruleName} [${routingRule.routingRuleId}] " + ec.message.getErrorsString())
                                    ec.message.clearAll()
                                }
                                brokeredItemCount += actionResult?.brokeredItemCount ?: 0
                                /*
                                    If runNextRule is false, do not execute the next rule.
                                    The order routing rule result will return the next rule to execute.
                                    However, if all items are either brokered or moved to a queue based on the configured action,
                                    there is no need to execute the next rule.
                                */
                                if (!actionResult?.runNextRule) {
                                    /* If an order is routed to a facility, all subsequent order routing rule executions should be excluded */
                                    break
                                }
                            } else {
                                ec.logger.warn("Ignoring order routing rule errors " + ec.message.getErrorsString())
                                /*
                                    Clearing the message after processing, as it may cause an error if not reset.
                                    If the error message is not cleared, it may interfere with the execution of the next rule,
                                    resulting in failure of subsequent logic.
                                    Therefore, we ensure the error message is cleared to allow proper execution of the next rule.
                                */
                                ec.message.clearAll()
                            }
                        }
                    }
                }
            ]]></script>
            <return message="Attempted ${attemptedCount} ${selectOrderItemSeqId?'item(s)':'ship group(s)'} for the '${orderRouting.routingName} [${orderRoutingId}] order routing"/>
        </actions>
    </service>

    <service verb="run" noun="OrderRoutingRule" transaction-timeout="36000">
        <description>
            To dynamically fetch and allocate inventory for order fulfillment based on specific routing rule configurations.
            These rules can encompass various criteria such as geographic location, inventory levels, delivery times, and cost efficiency.
        </description>
        <in-parameters>
            <parameter name="routingRuleId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="shipGroupSeqId" required="true"/>
            <parameter name="orderItemSeqId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="suggestedFulfillmentLocations"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="orderRoutingRule" cache="true"/>
            <if condition="!orderRoutingRule">
                <return error="true" message="No order routing rule found for id ${routingRuleId}"/>
            </if>
            <if condition="!'RULE_ACTIVE'.equals(orderRoutingRule.statusId)">
                <return error="true" message="Order routing ${orderRoutingRule.ruleName} [${routingRuleId}] is not active"/>
            </if>
            <log message="Executing order routing rule ${orderRoutingRule.ruleName?:''} [${routingRuleId}] for orderId ${orderId} and shipGroupSeqId ${shipGroupSeqId}"/>

            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleInvCond" list="inventoryConditions">
                <econdition field-name="routingRuleId" from="routingRuleId"/>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <set field="inventoryFilterMap" from="[:]" />
            <filter-map-list list="inventoryConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <iterate list="filterConditions" entry="filterCondition">
                <script>
                    inventoryFilterMap.put(filterCondition.fieldName, filterCondition)
                </script>
            </iterate>
            <!--
                Conversion factors for distance measurements from meters:
                1 meter = 0.001 kilometers (to convert meters to kilometers, multiply by 0.001).
                1 meter = 0.000621371 miles (to convert meters to miles, multiply by 0.000621371).
            -->
            <set field="conversionFactor" value="0.000621371"/>
            <set field="measurementSystem" from="inventoryFilterMap?.measurementSystem?.fieldValue" default-value="IMPERIAL"/>
            <if condition="measurementSystem.equals('METRIC')">
                <set field="conversionFactor" value="0.001"/>
            </if>
            <filter-map-list list="inventoryConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <order-map-list list="sortFields">
                <order-by field-name="sequenceNum"/>
            </order-map-list>
            <set field="brokeringOffset" from="ZonedDateTime.now().getOffset()"/>
            <!--  We have to get the ofbiz group name, used ProductStore entity to get the OFBiz group name-->
            <set field="productStore" from="ec.entity.getEntityDefinition('org.apache.ofbiz.product.store.ProductStore')"/>
            <set field="inventorySortByList" from="sortFields != null ? sortFields.fieldName:[]" type="List"/>
            <set field="templateLoc" value="component://order-routing/sql/InventorySourceSelector.sql.ftl"/>
            <set field="suggestedFulfillmentLocations" from="[]"/>
            <script><![CDATA[
                try {
                Writer writer = new StringWriter()
                ec.resourceFacade.template(templateLoc, writer)
                //ec.logger.info("======writer==${writer}==")
                ec.getEntity().getConnection(productStore.getEntityGroupName()).withCloseable ({ java.sql.Connection con ->
                con.createStatement().withCloseable({ statement ->
                    statement.executeQuery(writer.toString()).withCloseable({resultSet ->
                        while (resultSet.next()) {
                            suggestedFulfillmentLocations.add([
                                orderId: resultSet.getString('ORDER_ID'),
                                orderItemSeqId: resultSet.getString('ORDER_ITEM_SEQ_ID'),
                                //productId: resultSet.getString('PRODUCT_ID'),
                                shipGroupTotalQty: resultSet.getInt('ship_group_total_qty'),
                                itemQty: resultSet.getInt('ITEM_QTY'),
                                routedItemQty: resultSet.getInt('ROUTED_ITEM_QTY'),
                                facilityTypeId: resultSet.getString('FACILITY_TYPE_ID'),
                                facilityId: resultSet.getString('FACILITY_ID'),
                                distance: resultSet.getString('distance')
                            ])
                        }
                    })
                })
                })
                } catch (Exception e) {
                    ec.logger.error("Error executing order routing rule ${orderRoutingRule.ruleName} [${routingRuleId}] : ${e.getCause()}")
                }
            ]]></script>
        </actions>
    </service>

    <service verb="eval" noun="OrderRoutingActions" transaction-timeout="3600">
        <description>
            To dynamically evaluate and apply actions dictated by order routing rules, ensuring that orders are fulfilled in the most efficient and effective manner.
            This evaluation process determines the optimal steps for order fulfillment based on predefined criteria and actions associated with routing rules.
        </description>
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="shipGroupSeqId" required="true"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="changeReasonEnumId"/>
            <parameter name="routingRunId"/>
            <parameter name="routingRuleId" required="true"/>
            <parameter name="suggestedFulfillmentLocations" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="runNextRule" type="Boolean"/>
            <parameter name="brokeredItemCount" type="Long"/>
        </out-parameters>
        <actions>
            <set field="runNextRule" value="true" type="Boolean"/>
            <set field="brokeredItemCount" value="0" type="Long"/>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="routingRule" cache="true"/>
            <entity-find-related-one value-field="routingRule" relationship-name="co.hotwax.order.routing.OrderRouting" to-value-field="orderRouting" cache="true"/>
            <entity-find-related-one value-field="orderRouting" relationship-name="co.hotwax.order.routing.OrderRoutingGroup" to-value-field="orderRoutingGroup" cache="true"/>
            <entity-find-one entity-name="org.apache.ofbiz.order.order.OrderItemShipGroup" value-field="orderItemShipGroup"/>
            <entity-find entity-name="org.apache.ofbiz.order.order.OrderItem" list="orderItems">
                <econditions>
                    <econdition field-name="orderId" from="orderId"/>
                    <econdition field-name="shipGroupSeqId" from="shipGroupSeqId"/>
                    <econdition field-name="orderItemSeqId" from="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="statusId" value="ITEM_APPROVED"/>
                </econditions>
            </entity-find>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleAction" list="ruleActions" cache="true">
                <econditions>
                    <econdition field-name="routingRuleId" from="routingRuleId"/>
                    <econdition field-name="actionValue"  operator="is-not-null"/>
                </econditions>
            </entity-find>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleInvCond" list="extraConditions" cache="true">
                <econdition field-name="routingRuleId" from="routingRuleId"/>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <filter-map-list list="extraConditions" to-list="shipmentThresholds">
                <field-map field-name="fieldName" value="shipmentThreshold"/>
            </filter-map-list>
            <set field="shipmentThreshold" from="shipmentThresholds[0]?.fieldValue" type="BigDecimal" default-value="0"/>
            <filter-map-list list="extraConditions" to-list="brokerIfAllItemsAvailableCond">
                <field-map field-name="fieldName" value="brokerIfAllItemsAvailable"/>
            </filter-map-list>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleInvCond" list="measurementSystems">
                <econdition field-name="routingRuleId" from="routingRuleId"/>
                <econdition field-name="fieldName" value="measurementSystem"/>
            </entity-find>
            <set field="measurementSystem" from="measurementSystems?measurementSystems[0]: [:]"/>
            <set field="brokerIfAllItemsAvailable" from="brokerIfAllItemsAvailableCond[0]?.fieldValue" default-value="false" type="Boolean"/>
            <script><![CDATA[
                    import java.time.format.DateTimeFormatter;
                    import java.time.ZonedDateTime
                    import java.util.stream.Collectors;
                    import org.moqui.entity.EntityCondition

                    // If a single assignment is preferred, then SQL will return a result only if all the ship group items are available at a single location.
                    def actionMap = ruleActions.collectEntries { [it.actionTypeEnumId, it.actionValue] }
                    facilityAllocation = [];
                    def comments="${orderRoutingGroup.groupName} : Inventory found for ${routingRule.ruleName}.";
                    def routingRuleName = "${orderRoutingGroup.groupName} : ${orderRouting.routingName} : ${routingRule.ruleName}]"
                    def suggestedFacilityIds = suggestedFulfillmentLocations.facilityId as Set

                    if (!routingRule.assignmentEnumId || 'ORA_SINGLE'.equals(routingRule.assignmentEnumId)) {
                        // SQL will not return results if items are not available at a single location.
                        // Additional check to ensure all items are available at a single location.

                        boolean allItemsRouted = orderItems?.every { orderItem ->
                            def routedItem = suggestedFulfillmentLocations.find { it.orderId == orderItem.orderId && it.orderItemSeqId == orderItem.orderItemSeqId }
                            return routedItem && routedItem.routedItemQty == orderItem.quantity
                        }
                        if (allItemsRouted && suggestedFacilityIds.size() == 1) {
                            comments = "${orderRoutingGroup.groupName} : Inventory found at a single location for ${routingRule.ruleName}"
                        } else {
                            comments = "${orderRoutingGroup.groupName} : Inventory not found at a single location for ${routingRule.ruleName}."
                            ec.logger.info("Inventory not found at single location for ${routingRule.ruleName} [${routingRule.routingRuleId}] for orderId ${orderId} and shipGroupSeqId ${shipGroupSeqId}");
                            suggestedFulfillmentLocations = []
                        }
                    }

                    //prepare map for brokered items
                    def queue = null, autoCancelDate = null, brokeredItemsSeqIds = [], allocateFacilityToItems = true, orderAdjustments = null ;
                    if (suggestedFulfillmentLocations) {
                        brokeredItemCount = suggestedFulfillmentLocations.size();
                        brokeredItemsSeqIds = suggestedFulfillmentLocations.orderItemSeqId;
                        def checkShipmentThreshold = false;
                        def unfillableItems = orderItems.stream().filter(i -> !brokeredItemsSeqIds.contains(i.orderItemSeqId)).collect(Collectors.toList())

                        if (brokerIfAllItemsAvailable && unfillableItems) {
                            allocateFacilityToItems = false;
                            comments = "${orderRoutingGroup.groupName} : Inventory is not available for all items for rule ${routingRule.ruleName}."
                            ec.logger.info("Inventory is not available for all items condition not met for rule ${routingRule.ruleName} [${routingRule.routingRuleId}] for orderId ${orderId} and shipGroupSeqId ${shipGroupSeqId}");
                        }
                        if (allocateFacilityToItems && shipmentThreshold > 0 && !(suggestedFacilityIds.size() == 1 && !unfillableItems)) {
                            checkShipmentThreshold = true
                        }
                        if (checkShipmentThreshold) {
                            orderAdjustments = ec.entity.find("org.apache.ofbiz.order.order.OrderAdjustment")
                                    .condition("orderId", orderId)
                                    .condition("orderItemSeqId", EntityCondition.NOT_EQUAL, "_NA_").list();
                            if (unfillableItems) {
                                def result = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.calculate#ItemSubtotal")
                                        .parameters([orderItems: unfillableItems, orderAdjustments: orderAdjustments]).call()
                                if (shipmentThreshold > result?.subTotal) {
                                    allocateFacilityToItems = false;
                                }
                            }
                        }
                        if (allocateFacilityToItems) {
                            brokeredItemCount = suggestedFulfillmentLocations.size();
                            suggestedFacilityIds.each { facilityId->
                                def facilityItems = suggestedFulfillmentLocations.collect()
                                filterMapList(facilityItems, ["facilityId":facilityId], false)
                                def items = facilityItems.collect { [orderItemSeqId: it.orderItemSeqId, quantity: it.itemQty] }
                                if (checkShipmentThreshold) {
                                    def brokeredItems = orderItems.stream().filter(i -> (items.orderItemSeqId).contains(i.orderItemSeqId)).collect(Collectors.toList())
                                    result = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.calculate#ItemSubtotal")
                                            .parameters([orderItems: brokeredItems, orderAdjustments: orderAdjustments])
                                            .call()
                                    if (shipmentThreshold > result?.subTotal) {
                                        allocateFacilityToItems = false;
                                    }
                                }

                                def suggestedShipMethod;
                                if (orderItemShipGroup.shipmentMethodTypeId) {
                                    def methodResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.get#SuggestedShippingMethod")
                                        .parameters([suggestedFulfillmentLocations: facilityItems, orderShipmentMethodTypeId: orderItemShipGroup.shipmentMethodTypeId, measurementSystem: measurementSystem?.fieldValue])
                                        .call()
                                        if (ec.message.hasError()) {
                                            ec.logger.warn("Ignoring suggested ship method errors for ${routingRule.ruleName} [${routingRule.routingRuleId}] " + ec.message.getErrorsString())
                                            ec.message.clearErrors()
                                            ec.message.clearAll()
                                        } else {
                                            def suggestedShipMethods = methodResult?.suggestedShipMethods
                                            suggestedShipMethod = suggestedShipMethods?.get(facilityId);
                                        }
                                }
                                facilityAllocation.add([facilityId:facilityId, items: items, comments: comments, routingRule: routingRuleName, changeReasonEnumId: changeReasonEnumId?:"BROKERED",
                                        routingGroupId: orderRoutingGroup.routingGroupId, orderRoutingId:orderRouting.orderRoutingId, routingRuleId:routingRule.routingRuleId,
                                        routingRunId: routingRunId, suggestedShipMethodTypeId: suggestedShipMethod])
                            }
                            if (!allocateFacilityToItems) {
                                comments = "${orderRoutingGroup.groupName} : Shipment threshold not met for rule ${routingRule.ruleName}."
                                ec.logger.info("Shipment threshold condition not met for rule ${routingRule.ruleName} [${routingRule.routingRuleId}] for orderId ${orderId} and shipGroupSeqId ${shipGroupSeqId} and allocateFacilityToItems ${allocateFacilityToItems}");
                            }
                        }
                        if (!allocateFacilityToItems) {
                            facilityAllocation = []
                            brokeredItemsSeqIds = [];
                            brokeredItemCount = 0;
                        }
                    }
                    def unfillableItems = orderItems.stream().filter { i -> !brokeredItemsSeqIds.contains(i.orderItemSeqId) }
                                .map { i -> [orderItemSeqId: i.orderItemSeqId, quantity: i.quantity] }.collect(Collectors.toList())
                    if (unfillableItems) {
                        if (!comments) {
                            if (!suggestedFulfillmentLocations) {
                                comments = "${orderRoutingGroup.groupName}: No inventory found for ${routingRule.ruleName}."
                            } else {
                                comments = "${orderRoutingGroup.groupName}: Partially available item inventory found for ${routingRule.ruleName}."
                            }
                        }
                        // If unfillable items found, check for actions.
                        if (actionMap.get('ORA_MV_TO_QUEUE') != null) {
                            queue = actionMap.get('ORA_MV_TO_QUEUE');
                            comments += "Unfillable items moved to ${queue}."
                            // If the action is to move to a queue, then there is no need to run the next rule, as all unfillable items will be moved to the queue.
                            runNextRule = false
                        }
                        def clearAutoCancelDate = basicConvert(actionMap.get('ORA_RM_CANCEL_DATE'), 'Boolean') ?: false
                        if (clearAutoCancelDate || actionMap.get('ORA_AUTO_CANCEL_DAYS') != null) {
                            if (!queue) {
                                queue = orderItemShipGroup.facilityId
                            }
                            if (!clearAutoCancelDate && actionMap.get('ORA_AUTO_CANCEL_DAYS') != null) {
                                comments += "Set the auto-cancel date to ${actionMap.get('ORA_AUTO_CANCEL_DAYS')} days from today."
                                autoCancelDate = ZonedDateTime.now().plusDays(actionMap.get('ORA_AUTO_CANCEL_DAYS') as Long).format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"))
                            } else if (clearAutoCancelDate) {
                                comments += "Clear the auto-cancel date."
                            }
                        }
                        if (queue || autoCancelDate || clearAutoCancelDate) {
                            facilityAllocation.add([facilityId: queue, comments: comments, routingRule:routingRuleName, changeReasonEnumId:changeReasonEnumId?:"UNFILLABLE",
                                    items: unfillableItems.collect { [orderItemSeqId: it.orderItemSeqId,quantity: it.quantity, autoCancelDate: autoCancelDate, clearAutoCancelDate: clearAutoCancelDate]},
                                    routingGroupId: orderRoutingGroup.routingGroupId, orderRoutingId:orderRouting.orderRoutingId, routingRuleId:routingRule.routingRuleId,
                                    routingRunId: routingRunId])
                        }
                    } else {
                        //If all items allocated no need to run next rule
                        runNextRule = false
                    }
                ]]></script>
            <if condition="facilityAllocation">
                <log message="Facility allocation for order Id [${orderId}:${shipGroupSeqId}${orderItemSeqId?':' + orderItemSeqId :''}]: ${facilityAllocation}, applied under the '${routingRule.ruleName} [${routingRule.routingRuleId}]' routing rule."/>
                <script><![CDATA[
                    try {
                        outResult = ec.service.sync().name("co.hotwax.oms.impl.OrderReservationServices.process#OrderFacilityAllocation")
                                .requireNewTransaction(true).transactionTimeout(120)
                                .parameters([orderId: orderId, facilityAllocation: facilityAllocation])
                                .call()
                        if (ec.message.hasError()) {
                            ec.logger.warn("Ignoring facility allocation errors for ${routingRule.ruleName} [${routingRule.routingRuleId}] " + ec.message.getErrorsString())
                            ec.message.clearErrors()
                            ec.message.clearAll()
                        }
                    } catch (Throwable e) {
                        ec.logger.error("Error while facility allocation: ${e.getMessage()}")
                        ec.message.clearErrors()
                        ec.message.clearAll()
                    }
                ]]></script>
                <log message="Facility allocation result: ${outResult}"/>
            <else>
                <log message="No facility allocation found for orderId [${orderId}] for routing rule ${routingRule.ruleName} [${routingRule.routingRuleId}}"/>
            </else>
            </if>
        </actions>
    </service>

    <!-- We can achieve this by OrderRoutingGroup and ServiceJob, as both the entity belongs to different database so we can;t create join between them -->
    <service verb="get" noun="OrderRoutingGroupSchedule">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="schedule" type="Map">
                <auto-parameters entity-name="moqui.service.job.ServiceJob"/>
            </parameter>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="OrderRoutingGroup not found for specified routingGroupId [${routingGroupId}]."/>
            </if>
            <if condition="!orderRoutingGroup.jobName">
                <return message="No schedule found for order routing group ${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}]/"/>
            </if>
            <entity-find-one entity-name="moqui.service.job.ServiceJob" value-field="serviceJob">
                <field-map field-name="jobName" from="orderRoutingGroup.jobName"/>
            </entity-find-one>
            <if condition="serviceJob">
                <script><![CDATA[
                    schedule = serviceJob.getMap()
                    try {
                        schedule.cronDescription = co.hotwax.util.MaargUtil.getCronDescription(schedule.cronExpression, ec.user.getLocale())
                        nextExecutionTime = co.hotwax.util.MaargUtil.getNextExecutionTime(serviceJob?.cronExpression, TimeZone.getDefault())
                        if (nextExecutionTime != null) {
                            schedule.nextExecutionDateTime = nextExecutionTime.toInstant().toEpochMilli()
                        }
                        schedule.executionTimeZone = TimeZone.getDefault().getID()
                    } catch (Exception e) {
                        ec.logger.error("Error getting cron description: ${e.getMessage()}")
                        schedule.cronDescription = e.getMessage()
                    }
                ]]></script>
            </if>
        </actions>
    </service>
    <service verb="store" noun="OrderRoutingGroupSchedule">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
            <auto-parameters entity-name="moqui.service.job.ServiceJob" include="nonpk">
                <exclude field-name="description"/>
                <exclude field-name="serviceName"/>
            </auto-parameters>
        </in-parameters>
        <out-parameters>
            <parameter name="jobName"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="OrderRoutingGroup not found for specified routingGroupId [${routingGroupId}]."/>
            </if>
            <if condition="!orderRoutingGroup.productStoreId">
                <return message="No productStore associated with routing group ${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}]/"/>
            </if>
            <if condition="cronExpression">
                <!--validate cron expression -->
                <script><![CDATA[
                    try {
                        cron = org.moqui.impl.service.ScheduledJobRunner.getCron(cronExpression)
                        cron.validate()
                    } catch (Exception e) {
                        ec.logger.error("Invalid cron expression : ${e.getMessage()}")
                        ec.message.addError("Invalid cron expression 2: ${e.getMessage()}")
                        return
                    }
                ]]></script>
            </if>
            <if condition="orderRoutingGroup.jobName">
                <entity-find-one entity-name="moqui.service.job.ServiceJob" value-field="serviceJob">
                    <field-map field-name="jobName" from="orderRoutingGroup.jobName"/>
                </entity-find-one>
            </if>
            <set field="description" value="Service job for order routing group ${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}]"/>
            <set field="serviceName" value="co.hotwax.order.routing.OrderRoutingServices.run#OrderRoutingGroup"/>
            <!-- Default transaction timeout for service job is 1800 seconds, overriding it and set the timeout to 3600 seconds-->
            <if condition="!serviceJob">
                <if condition="!paused">
                    <set field="paused" value="N"/>
                </if>
                <set field="transactionTimeout" from="transactionTimeout" default-value="3600"/>
                <set field="jobName" value="Order_Routing_Group_${orderRoutingGroup.routingGroupId}"/>
                <service-call name="create#moqui.service.job.ServiceJob" in-map="context + [jobName: jobName]" out-map="context"/>
                <!-- Set the JobName in orderRoutingGroup entity -->
                <set field="orderRoutingGroup.jobName" from="jobName"/>
                <service-call name="update#co.hotwax.order.routing.OrderRoutingGroup" in-map="[routingGroupId:routingGroupId, jobName: jobName]"/>
                <!--
                    For order routing scheduling we need only two parameters
                    - productStoreId - This is to ensure only one routing is in execution for an ProductStore
                    - routingGroupId
                 -->
                <service-call name="create#moqui.service.job.ServiceJobParameter" in-map="[jobName: jobName, parameterName: 'routingGroupId', parameterValue: routingGroupId]"/>
                <service-call name="create#moqui.service.job.ServiceJobParameter" in-map="[jobName: jobName, parameterName: 'productStoreId', parameterValue: orderRoutingGroup.productStoreId]"/>
                <return message="Order routing group schedule has been created successfully."/>
            <else>
                <service-call name="update#moqui.service.job.ServiceJob" in-map="context + [jobName: serviceJob.jobName]" out-map="context"/>
                <return message="Order routing group ${orderRoutingGroup.groupName?:routingGroupId} schedule has been updated successfully."/>
            </else>
            </if>
        </actions>
    </service>

    <service verb="get" noun="RoutingOrderCount">
        <description>
            Return the eligible order item count for the Order Routing
        </description>
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderItemCount" type="Long"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="true"/>
            <if condition="!orderRouting">
                <return error="true" message="No order routing found for id ${orderRoutingId}"/>
            </if>
            <entity-find-related-one value-field="orderRouting" relationship-name="co.hotwax.order.routing.OrderRoutingGroup" to-value-field="orderRoutingGroup" cache="true"/>
            <entity-find entity-name="co.hotwax.order.routing.OrderFilterCondition" list="orderFilterConditions">
                <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                <order-by field-name="sequenceNum"/>
                <order-by field-name="createdDate DESC"/>
            </entity-find>
            <!-- Prepare the filter conditions for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <!-- Prepare the order by for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <set field="orderSortByList" from="sortFields != null ? sortFields.fieldName:[]" type="List"/>

            <set field="orderTypeId" value="SALES_ORDER"/>
            <set field="productStoreId" from="orderRoutingGroup.productStoreId"/>
            <set field="itemStatusId" value="ITEM_APPROVED"/>
            <set field="orderStatusId" value="ORDER_APPROVED"/>
            <set field="facilityParentTypeId" value="VIRTUAL_FACILITY"/>
            <set field="selectOrderItemSeqId" value="false" type="Boolean"/>
            <set field="orderFilterConditions" from="[]"/>
            <iterate list="filterConditions" entry="filterCondition">
                <if condition='"promiseDaysCutoff".equals(filterCondition.fieldName)'>
                    <if condition="filterCondition.fieldValue">
                        <!--
                        When promiseDaysCutoff is configured, it acts as a constraint that prioritizes order items to be processed and allocated in a way that meets the delivery promise timeframe.
                        The brokering process is executed at the individual order item level rather than at a more aggregated shipGroup level.
                        -->
                        <set field="selectOrderItemSeqId" value="true" type="Boolean"/>
                        <script>
                            promisedDatetime = java.time.ZonedDateTime.now().plusDays(filterCondition.fieldValue as Long)
                                    .with(java.time.LocalTime.MAX).format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"))
                        </script>
                        <set field="orderFilterConditions" from="orderFilterConditions + [fieldName: 'promisedDatetime', operator: filterCondition.operator, fieldValue: promisedDatetime]"/>
                    </if>
                    <else-if condition='"originFacilityGroupId".equals(filterCondition.fieldName)'>
                        <set field="facilityGroupCondition" from="filterCondition"/>
                    </else-if>
                    <else-if condition='"productCategoryId".equals(filterCondition.fieldName)'>
                        <set field="productCategoryCondition" from="filterCondition"/>
                    </else-if>
                    <else>
                        <set field="orderFilterConditions" from="orderFilterConditions + filterCondition"/>
                    </else>
                </if>
            </iterate>
            <set field="queryCount" value="true" type="Boolean"/>
            <set field="templateLoc" value="component://order-routing/sql/EligibleOrdersQuery.sql.ftl"/>
            <set field="productStore" from="ec.entity.getEntityDefinition('org.apache.ofbiz.product.store.ProductStore')"/>
            <set field="orderItemCount" value="0" type="Long"/>
            <log message="Fetching order count with condition ${orderFilterConditions} for routing ${orderRouting.routingName} [${orderRoutingId}]"/>
            <script><![CDATA[
                Writer countWriter = new StringWriter()
                ec.resourceFacade.template(templateLoc, countWriter)
                //ec.logger.info("Eligible orders count sql: ${countWriter}")
                ec.getEntity().getConnection(productStore.getEntityGroupName()).withCloseable ({ java.sql.Connection con ->
                    con.createStatement().withCloseable({ statement ->
                        statement.executeQuery(countWriter.toString()).withCloseable({resultSet ->
                            if (resultSet.next()) { orderItemCount = resultSet.getLong(1) }
                        })
                    })
                })
            ]]></script>
        </actions>
    </service>
    <service verb="get" noun="OrderFilterSql">
        <description>
            This service will return the eligible orders sql for order routing
        </description>
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="statusId"/>
            <parameter name="sql" allow-html="any"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="true"/>
            <if condition="!orderRouting">
                <return error="true" message="No order routing found for id ${orderRoutingId}"/>
            </if>
            <set field="statusId" from="orderRouting.statusId"/>
            <entity-find-related-one value-field="orderRouting" relationship-name="co.hotwax.order.routing.OrderRoutingGroup" to-value-field="orderRoutingGroup" cache="true"/>
            <log message="Started order routing ${orderRouting.routingName} [${orderRoutingId}]"/>

            <entity-find entity-name="co.hotwax.order.routing.OrderFilterCondition" list="orderFilterConditions">
                <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                <order-by field-name="sequenceNum"/>
                <order-by field-name="createdDate DESC"/>
            </entity-find>
            <!-- Prepare the filter conditions for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <!-- Prepare the order by for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <set field="orderSortByList" from="sortFields != null ? sortFields.fieldName:[]" type="List"/>

            <set field="orderTypeId" value="SALES_ORDER"/>
            <set field="productStoreId" from="orderRoutingGroup.productStoreId"/>
            <set field="itemStatusId" value="ITEM_APPROVED"/>
            <set field="orderStatusId" value="ORDER_APPROVED"/>
            <set field="facilityParentTypeId" value="VIRTUAL_FACILITY"/>
            <set field="selectOrderItemSeqId" value="false" type="Boolean"/>
            <set field="orderFilterConditions" from="[]"/>
            <set field="attemptedCount" value="0" type="Integer"/>
            <iterate list="filterConditions" entry="filterCondition">
                <if condition='"promiseDaysCutoff".equals(filterCondition.fieldName)'>
                    <if condition="filterCondition.fieldValue">
                        <!--
                        When promiseDaysCutoff is configured, it acts as a constraint that prioritizes order items to be processed and allocated in a way that meets the delivery promise timeframe.
                        The brokering process is executed at the individual order item level rather than at a more aggregated shipGroup level.
                        -->
                        <set field="selectOrderItemSeqId" value="true" type="Boolean"/>
                        <script>
                            promisedDatetime = java.time.ZonedDateTime.now().plusDays(filterCondition.fieldValue as Long)
                                    .with(java.time.LocalTime.MAX).format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"))
                        </script>
                        <set field="orderFilterConditions" from="orderFilterConditions + [fieldName: 'promisedDatetime', operator: filterCondition.operator, fieldValue: promisedDatetime]"/>
                    </if>
                    <else-if condition='"originFacilityGroupId".equals(filterCondition.fieldName)'>
                        <set field="facilityGroupCondition" from="filterCondition"/>
                    </else-if>
                    <else-if condition='"productCategoryId".equals(filterCondition.fieldName)'>
                        <set field="productCategoryCondition" from="filterCondition"/>
                    </else-if>
                    <else>
                        <set field="orderFilterConditions" from="orderFilterConditions + filterCondition"/>
                    </else>
                </if>
            </iterate>
            <set field="templateLoc" value="component://order-routing/sql/EligibleOrdersQuery.sql.ftl"/>
            <script><![CDATA[
                Writer writer = new StringWriter()
                ec.resourceFacade.template(templateLoc, writer)
                sql = writer.toString();
            ]]></script>
        </actions>
    </service>
    <service verb="get" noun="OrderRoutingRuleSql">
        <description>
            The Routing Rule ID SQL Query Service is designed to generate SQL queries that fetch inventory allocation based on specific routing rule IDs.
            This service helps in retrieving accurate inventory data by applying predefined routing rules.
        </description>
        <in-parameters>
            <parameter name="routingRuleId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="statusId"/>
            <parameter name="sql" allow-html="any"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="orderRoutingRule" cache="true"/>
            <if condition="!orderRoutingRule">
                <return error="true" message="No order routing rule found for id ${routingRuleId}"/>
            </if>
            <set field="statusId" from="orderRoutingRule.statusId"/>

            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleInvCond" list="inventoryConditions">
                <econdition field-name="routingRuleId" from="routingRuleId"/>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <set field="inventoryFilterMap" from="[:]" />
            <filter-map-list list="inventoryConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <iterate list="filterConditions" entry="filterCondition">
                <script>
                    inventoryFilterMap.put(filterCondition.fieldName, filterCondition)
                </script>
            </iterate>
            <set field="conversionFactor" value="0.000621371"/>
            <set field="measurementSystem" from="inventoryFilterMap?.measurementSystem?.fieldValue" default-value="IMPERIAL"/>
            <if condition="measurementSystem.equals('METRIC')">
                <set field="conversionFactor" value="0.0001"/>
            </if>
            <filter-map-list list="inventoryConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <order-map-list list="sortFields">
                <order-by field-name="sequenceNum"/>
            </order-map-list>
            <set field="brokeringOffset" from="ZonedDateTime.now().getOffset()"/>
            <set field="inventorySortByList" from="sortFields != null ? sortFields.fieldName:[]" type="List"/>
            <set field="templateLoc" value="component://order-routing/sql/InventorySourceSelector.sql.ftl"/>
            <set field="suggestedFulfillmentLocations" from="[]"/>
            <script><![CDATA[
                try {
                    Writer writer = new StringWriter()
                    ec.resourceFacade.template(templateLoc, writer)
                    sql = writer.toString();
                } catch (Exception e) {
                    ec.logger.error("Error executing order routing rule ${orderRoutingRule.ruleName} [${routingRuleId}] : ${e.getMessage()}")
                }
            ]]></script>
        </actions>
    </service>
    <service verb="calculate" noun="ItemSubtotal">
        <in-parameters>
            <parameter name="orderItems" type="List" required="true"/>
            <parameter name="orderAdjustments" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="subTotal"/>
        </out-parameters>
        <actions>
            <set field="subTotal" value="0" type="BigDecimal"/>
            <iterate list="orderItems" entry="orderItem">
                <set field="itemAmount" from="orderItem.quantity * orderItem.unitPrice" type="BigDecimal"/>
                <filter-map-list list="orderAdjustments" to-list="itemAdjustments">
                    <field-map field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                </filter-map-list>
                <script>
                    def adjAmount = itemAdjustments?itemAdjustments.collect { adj -> adj.amount ?: 0 }.sum(): 0.0;
                </script>
                <set field="subTotal" from="subTotal+ itemAmount + adjAmount"/>
            </iterate>
        </actions>
    </service>
    <service verb="get" noun="SuggestedShippingMethod">
        <in-parameters>
            <parameter name="measurementSystem" default-value="IMPERIAL"/>
            <parameter name="orderShipmentMethodTypeId" required="true"/>
            <parameter name="suggestedFulfillmentLocations" type="List"></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="suggestedShipMethods" type="Map" required="true"/>
        </out-parameters>
        <actions>
            <set field="suggestedShipMethods" from="[:]"/>
            <entity-find-one entity-name="org.apache.ofbiz.shipment.shipment.ShipmentMethodType" value-field="shipmentMethodType" cache="true">
                <field-map field-name="shipmentMethodTypeId" from="orderShipmentMethodTypeId"/>
            </entity-find-one>
            <if condition="!shipmentMethodType">
                <return message="No shipment method type found for ${orderShipmentMethodTypeId}"/>
            </if>

            <set field="shipmentMethodsTypeIds" from="[orderShipmentMethodTypeId]" />
            <if condition="shipmentMethodType.parentTypeId">
                <set field="shipmentMethodsTypeIds" from="shipmentMethodsTypeIds + shipmentMethodType.parentTypeId"/>
            </if>
            <if condition="'IMPERIAL'.equalsIgnoreCase(measurementSystem)">
                <set field="nextDaySLA" value="230" type="Long"/>
                <set field="secondDaySLA" value="500" type="Long"/>
                <set field="thirdDaySLA" value="650" type="Long"/>
            <else>
                <set field="nextDaySLA" value="370" type="Long"/>
                <set field="secondDaySLA" value="805" type="Long"/>
                <set field="thirdDaySLA" value="1050" type="Long"/>
            </else>
            </if>
            <script><![CDATA[
                def suggestedFacilityIds = suggestedFulfillmentLocations.facilityId as Set
                suggestedFacilityIds.each { facilityId ->
                    // Filter facility items for the current facilityId
                    def facilityItems = suggestedFulfillmentLocations.collect()
                    filterMapList(suggestedFulfillmentLocations.collect(), ["facilityId": facilityId], false)

                    def item = facilityItems ? facilityItems[0] : null
                    if (item?.distance) {
                        def distance = basicConvert(item.distance, 'BigDecimal')
                        // Determine the suggested shipping method based on distance and available shipment types
                        def shippingMethod;

                        switch (true) {
                            case shipmentMethodsTypeIds.contains("NEXT_DAY"):
                                shippingMethod = (distance <= nextDaySLA) ? 'STANDARD' : 'NEXT_DAY'
                                break
                            case shipmentMethodsTypeIds.contains("SECOND_DAY"):
                                shippingMethod = (distance <= secondDaySLA) ? 'STANDARD' : 'SECOND_DAY'
                                break
                            case shipmentMethodsTypeIds.contains("THIRD_DAY"):
                                shippingMethod = (distance <= thirdDaySLA) ? 'STANDARD' : 'THIRD_DAY'
                                break
                            default:
                                shippingMethod = (distance != 0) ? 'STANDARD': null;
                                break
                        }
                        // Store the suggested shipping method for the facility
                        suggestedShipMethods.put(facilityId, shippingMethod)
                    }
                }
            ]]></script>

        </actions>
    </service>

    <!-- FIXME: This service should be part of oms -->
    <service  verb="reject" noun="OrderItems">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="notify" type="Boolean" default-value="false">
                <description>If set to true, an email notification will be sent on rejection, provided it is configured.</description>
            </parameter>
            <parameter name="items" type="List" required="true">
                <parameter name="item" type="Map">
                <description>A map containing details of the items to be rejected or moved.</description>
                <parameter name="facilityId">
                    <description>The facility ID of the order item's ship group.</description>
                </parameter>
                <parameter name="shipmentMethodTypeId">
                    <description>The shipment method of the order item's ship group.</description>
                </parameter>
                <parameter name="quantity" default-value="1">
                    <description>The quantity of the order item to be rejected. Defaults to 1.</description>
                </parameter>
                <parameter name="orderItemSeqId">
                    <description>The sequence ID of the order item.</description>
                </parameter>
                <parameter name="toFacilityId">
                    <description>The destination facility ID where the item will be moved after rejection.</description>
                </parameter>
                <parameter name="recordVariance">
                    <description>Set to true if a variance record needs to be created.</description>
                </parameter>
                <parameter name="rejectReason">
                    <description>The reason for rejecting the item.</description>
                </parameter>
            </parameter>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="rejectedItemsList" type="List">
                <parameter name="rejectedItem" type="Map">
                    <parameter name="orderId"/>
                    <parameter name="orderItemSeqId"/>
                    <parameter name="shipGroupSeqId"/>
                    <parameter name="shipmentMethodTypeId"/>
                    <parameter name="quantity"/>
                </parameter>
            </parameter>
        </out-parameters>
        <actions>
            <set field="payload" from="[orderId: orderId]"/>
            <set field="rejectedItems" from="[]"/>
            <iterate list="items" entry="item">
                <set field="item.orderId" from="orderId"/>
                <set field="item.naFacilityId" from="item.toFacilityId"/>
            </iterate>
            <set field="payload" from="payload + [items: items, notify: notify] "/>

            <service-call name="co.hotwax.order.routing.InventoryReservationServices.reject#OmsOrderItems" in-map="[payload: payload]" out-map="outResult"/>
            <set field="rejectedItemsList" from="outResult.rejectedItemsList"/>
        </actions>
    </service>
    <!-- Added a service instead of using a REST entity, as we need to fetch only recent record.
        We cannot pass the limit in a REST entity query, and setting the page limit would apply globally by default. -->
    <service  verb="get" noun="RecentRoutingHistory">
        <in-parameters>
            <parameter name="orderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="routingHistoryList" type="List">
                <auto-parameters entity-name="co.hotwax.facility.OrderFacilityChange"/>
            </parameter>
        </out-parameters>
        <actions>
            <entity-find entity-name="co.hotwax.order.routing.OrderFacilityChangeRecent" list="ofcList">
                <econdition field-name="orderId" from="orderId"/>
                <select-field field-name="orderId,orderItemSeqId,changeDatetime"/>
            </entity-find>
            <set field="routingHistoryList" from="[]"/>
            <iterate list="ofcList" entry="ofc">
                <entity-find entity-name="co.hotwax.facility.OrderFacilityChange" list="facilityChangeList">
                    <econdition field-name="orderId" from="ofc.orderId"/>
                    <econdition field-name="orderItemSeqId" from="ofc.orderItemSeqId"/>
                    <econdition field-name="changeDatetime" from="ofc.changeDatetime"/>
                </entity-find>
                <if condition="facilityChangeList">
                    <set field="routingHistoryList" from="routingHistoryList + facilityChangeList"/>
                </if>
            </iterate>
        </actions>
    </service>
</services>
